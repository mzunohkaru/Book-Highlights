# Devin ナレッジベース

## 概要

Devin は自律的な AI エンジニアで、ソフトウェア開発における様々なタスクを実行できます。個人的なイメージとしては「一流コンサル出身のジュニアエンジニア」として捉えられており、適切に指示すれば高い生産性を発揮します。

**基本的な期待値管理:**

- **「ジュニアエンジニア」として扱う**: 完璧な成果物を期待せず、人間による修正を前提とした活用
- **基本実装の土台**として利用し、人間が最終的な洗練を行う
- **協調的なアプローチ**が重要：人間の監視、戦略的な適用、継続的な学習

## Devin の得意なこと

### 1. コードレビュー・PR 関連

- **PR レビューの自動化**: 確認すべき観点を Knowledge に蓄積することで、確認漏れや同じミスを防げる
- **セルフレビューの支援**: PR の観点抜け漏れや QA チームとの議論のベースとして活用
- **PR 作成支援**: シンプルなプルリクエストの作成や説明文の生成
- **変更差分の抽出**: 既存実装の変更点を効率的に分析

### 2. Issue 管理・情報整理

- **Issue 作成の自動化**: Slack スレッドやミーティング内容から Issue を自動生成
- **Issue 分析**: 複数チーム間での知識共有や内容抽出
- **情報整理**: GitHub や Slack からの情報を構造化して整理

### 3. 単純作業の自動化

- **繰り返し作業**: 投げっぱなしでやってもらえる基本的な開発業務
- **ライブラリアップデート調査**: 破壊的変更や互換性を調査して Issue にまとめ
- **CI の修正**: テストエラーやビルドエラーの単純な修正
- **単体テストの実装**: TDD 開発における事前テスト作成
- **文言修正**: UI 文言やエラーメッセージの修正
- **フレームワークのアップグレード**: 既存パターンに基づいたアップデート作業
- **未使用機能フラグの削除**: 影響範囲が明確な機能削除作業

### 4. 明確なゴールがあるタスク

- **変更行数 100 ～ 200 行程度**: ゴールが明確で曖昧さが少ないタスク
- **小規模リファクタリング**: 特定の関数やコンポーネントの責務分離
- **バグ修正**: 原因が明確で対処方法が決まっているもの
- **コード移行**: JavaScript から TypeScript などの定型的な変換
- **API との新規統合**: 明確な仕様に基づく統合作業

### 5. CI/CD 関連の自動化

- **CI パスまでの自動化**: 「CI の ○○ が通るまで対応して」の指示で完全に動作する状態まで自動化
- **テスト失敗時の自動修正**: CI 失敗時に成功するまで自動的に修正を続行

## Devin が苦手なこと

### 1. 進捗管理とレスポンス

- 進捗の可視性が低い
- レスポンスが遅い場合がある
- 大きな修正では依頼/レビューが追いつかない

### 2. 高度な実装

- 複雑なアーキテクチャ設計
- 曖昧な要件での実装
- 抽象的な要素が含まれる作業
- **UI/美的要素の実装**: Figma デザインの実装など（「視力が良くない」）
- **高度な判断や創造性を要するタスク**: 明確な指示なしの創造的入力

### 3. プロンプト設計の課題

- 指示にないことを実行することがある
- 少しでも抽象的な要素があると正しく実装されない
- プロンプトの工夫が必要

### 4. PR 管理の不安定さ

- 指示していない PR レビューコメントに反応
- 不要な commit を積むことがある
- 他プロダクトリポジトリへの誤 push

### 5. 技術的制約

- **モバイルアプリ開発**: 実機テストができないため
- **大規模で複雑な編集**: 多数のファイルに渡る複雑な変更
- **依存関係が多いタスク**: 複雑な相互関係を持つシステム

### 6. パフォーマンス関連の問題

- **「コードのスープ」や「スパゲッティコード」**の生成
- **「無限ループ」や「技術的行き詰まり」**に陥る傾向
- **不可能なタスクの長時間追求**: かなりの時間と ACU を消費
- **長時間セッションでのパフォーマンス低下**: 10ACU 以上で効率が悪化

## 効果的な活用方法

### ACU 管理とセッション戦略

**ACU 使用量の最適化:**

- **10ACU 未満**でタスクを完了させる（長時間セッションはパフォーマンス低下）
- **1 セッション 1 タスクの原則**を守る
- セッション履歴が長くなりすぎた場合は新しいセッションを開始

**Slack でのセッション制御:**

- `mute`/`unmute`: メッセージ無視の切り替え
- `sleep`: 一時停止（ACU 節約、起動に 90 秒必要）
- `archive`: セッション終了とアーカイブ

### タスク分割戦略

**効果的な分割方法:**

- **人間の検証時間が 90 分未満**で済むサブタスクに分割
- **50 行単位**の小さな変更に分ける（大規模リファクタリングの場合）
- **独立して実行可能で後方互換性**のあるスライスに設計
- **明確な開始点と終了点、成功基準**を設定
- 最も単純なバージョンから開始し、仮定を早期にテスト

### Knowledge の活用

**管理方針:**

- 変動が大きく頻繁にアップデートが必要な内容を Knowledge に集約
- Rails の設計パターンや自社特有のドメイン知識
- 継続的な整理が重要

**推奨 Knowledge 設定:**

- コーディング規約とブランチ命名規則
- テストの実行方法と確認手順
- デプロイワークフローの詳細
- 「5 分以上迷ったら質問する」などの行動指針
- プロジェクト固有の API 仕様や設計パターン

**追加タイミング:**

- セッション終了時の Devin からのレコメンド
- エンジニアとして常識レベルだが Devin がうまく動かない場合
- GitHub リポジトリにないが、Notion や Slack にある情報

**Knowledge 管理のコツ:**

- **関連性の高いトリガー**を設定
- **小さな単位**に分割して管理
- 定期的に更新・整理する

### Playbook の活用

**構成要素:**

- **Procedure**: タスクの具体的な手順
- **Specifications**: タスク完了時に満たすべき条件
- **Advice**: Devin へのアドバイスや注意点
- **Forbidden Actions**: 実行してはいけない操作等の制約
- **Required from User**: 必要なユーザー提供情報

**活用のコツ:**

- 定型化可能な作業タスクは Playbook 化してチーム共有
- レビュー時のお作法や基本ルールはプロンプト側に記載

### Workspace の設定

- 全セッションに影響するため慎重に設定
- 毎回同じ指示をしている場合は見直しが必要
- 起動失敗が頻発する場合も要調整

## プロンプト設計のベストプラクティス

### 良いタスク指示

- ゴールが明確で具体的
- 何を以て成果物の品質を充足するかが明確
- Devin が自律的に判断できる程度に認知負荷を排除
- 段階的・体系的に整理された指示

**具体的なプロンプト例:**

```
✅ 良い例：「src/database/queries.js内のget_user_data関数を、
usersテーブルのuser_idカラムにインデックスを追加することで最適化してください。
変更後、npm testがパスすることを確認してください」
```

**効果的なプロンプト作成のコツ:**

- **可能な限り具体的**に指示する
- **十分なコンテキスト**、例、関連ドキュメントリンクを提供
- 参考となる既存実装のファイル名を明示
- **明確な成功基準**を設定
- プロジェクト固有のルールや期待される出力形式を説明

### 悪いタスク指示

- 曖昧なタスク（「なんとなく改善したい」など）
- 複数の解釈が可能な指示
- 想像力を要求する指示
- 抽象的な要素が含まれる指示

**避けるべき例:**

```
❌ 悪い例：「データベースのパフォーマンスを向上させる」
```

### Planner を意識した設計

- タスクをステップに分解
- チェックリストや実行計画の自動作成
- ファイルごとの明確なチェックリスト生成

## 人間と AI の協調戦略

### 積極的な監視と介入

- **リアルタイムで Devin の作業を観察**（組み込まれた IDE を活用）
- 道に迷った場合は早めに**軌道修正**または**手動引き継ぎ**
- Devin をデバッグするより手動の方が早い場合は切り替える
- **積極的な人間の監視**で ACU 浪費を防ぐ

### フィードバックループの確立

- **ユニットテストと統合テスト**で正確性を検証
- **CI/CD、Lint、静的解析**で自動フィードバック
- 良い作業を褒め、改善点を明確に伝える
- 失敗から学んだ知識を Devin のナレッジベースに追加
- **早期警告システム**として自動化されたフィードバックを活用

## 事前準備とセキュリティ

### 推奨事前準備

- 開発環境の適切なセットアップ
- 必要なツールや依存関係の導入
- 関連する既存実装の特定
- 要件定義の明確化
- テストケースの事前作成
- 参考となるコード例の準備

### セキュリティ対策

**必須のセキュリティ措置:**

- **最小特権アクセス**の原則
- **Secrets Manager**や安全な認証情報共有チャネルの利用
- 必須かつ厳格な**人間によるコードレビュー**（SAST/DAST による強化）
- **サプライチェーンスキャン**の実施
- 秘密情報の匿名化
- 行動監視の実装

**注意すべきリスク:**

- データ漏洩と知的財産侵害
- サプライチェーンの脆弱性
- 安全でないコードの生成（SQL インジェクション、XSS 等）
- 「自動化バイアス」（AI が生成した推奨事項を十分に吟味せずに受け入れる傾向）

## チーム運用のベストプラクティス

### 組織体制

- **オーナーシップを持つ担当者の設置**
- 定期的な知見共有
- Essential Guidelines の読み合わせ（超重要）

### 知見の蓄積

- Devin の得意・苦手なことの把握
- ベストプラクティス・Tips の共有
- 良い指示・悪い指示の例の蓄積

### 公式リソースの活用

- [Essential Guidelines](https://docs.devin.ai/essential-guidelines/when-to-use-devin)
- [効果的な指示方法](https://docs.devin.ai/essential-guidelines/instructing-devin-effectively)
- [良い指示と悪い指示の例](https://docs.devin.ai/essential-guidelines/good-vs-bad-instructions)

## 実装フロー例

### 基本フロー

1. **Issue 起票**: 詳細な要件定義
2. **Devin への依頼**: Slack や Devin UI 経由
3. **PR 作成**: Devin が自動で PR 作成
4. **レビュー**: 人間がレビューして指摘
5. **修正対応**: Devin が修正実装
6. **マージ**: 最終確認後にマージ

### GitHub Actions 連携

- PR 作成時の自動レビュー
- `devin-review`コメントでレビュー開始
- 新コミット追加時の自動チェック

## 開発プラクティス

### 安全な作業環境

- **Feature Flag**: 本番ユーザーから隔離してデプロイ
- **スプラウトクラス/メソッド**: 段階的なコード変更
- **進捗管理の外部化**: 作業状況の可視化

### テスト戦略

- テストコードがないと AI が自律的にフィードバックサイクルを回すのが困難
- TDD 開発における事前テスト実装の活用
- 静的解析やテスト失敗時の原因分析＆修正方針確認

### CI/CD 最適化

- ローカル実行を重視して remote push を削減
- Actions 費用削減
- CI の待機時間短縮

## 避けるべき落とし穴

### パフォーマンス低下の要因

- **長時間セッション（10ACU 以上）**: パフォーマンス低下と ACU 無駄遣い
- **曖昧で漠然とした指示**: 非生産的な探索サイクル
- **複雑すぎるタスクの一括実行**: 管理不能なスコープ
- **監視されていない自律性**: 道に迷って長時間作業

### よくある技術的問題

- **「コードのスープ」や「スパゲッティコード」**の生成
- **「無限ループ」や「技術的行き詰まり」**に陥る
- **不可能なタスクの長時間追求**で ACU 浪費
- コードレビューコメントの無視や不正確な対処
- 繰り返しセッション使用制限に達する（タスクが複雑すぎる証拠）

### コスト効率を下げる行動

- 頻繁なデバッグのやり取り
- 生成された PR への広範なコメント
- 初期評価での低い成功率（複雑なタスクでは 15%程度）

## 効果的な Tips

### 日常的な活用

- **Claude Code**: コードベース調査
- **壁打ち**: 作業タスクの分解
- **MCP 経由**: まとめて依頼

### 効率化のための実践テクニック

**段階的アプローチ:**

- **最も単純なバージョン**から開始
- 仮定を早期にテスト
- 増分的な完了を目指す
- トラブルシューティングを容易にする

**プロジェクト管理との連携:**

- GitHub Issue や Milestone との連携
- Devin 自身にタスクの細分化を依頼
- 適切な優先順位付けを実行

### トラブルシューティング

- 失敗 → 原因分析 → 修正方針確認のフロー設定
- テストや静的解析失敗時の対応パターン化

### 依頼作成の自動化

- 定型的なタスクの自動化
- 繰り返し作業のパターン化

## 2025 年の AI コーディング展望

- AI エージェントをチームメンバーとして捉える
- 丁寧なフィードバックの重要性
- GitHub Copilot × Devin の連携強化
- MCP（Model Context Protocol）の活用拡大

## まとめ

Devin は適切に活用すれば開発効率を大幅に向上させる強力なツールです。重要なのは：

1. **明確で具体的な指示**とプロンプトエンジニアリング
2. **適切な Knowledge・Playbook の整備**
3. **戦略的なタスク分割**と ACU 管理
4. **積極的な人間と AI の協調**
5. **セキュリティ対策**の徹底
6. **チーム全体での知見共有**
7. **継続的な改善とフィードバック**

数十名規模での運用実績からも、コードレビューや単純作業の自動化において特に高い効果を発揮することが確認されています。一方で、プロンプト設計や進捗管理の課題、技術的制約もあるため、**「ジュニアエンジニア」として適切な期待値を持ち**、チーム全体でベストプラクティスを共有しながら活用することが成功の鍵となります。

**投資対効果の最大化**には、Devin の能力と限界を理解し、適切なタスク選択、精密なプロンプト設計、効果的なタスク分割、積極的な協調作業が不可欠です。
